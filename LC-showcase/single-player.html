<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Super Metroid/Live Coaches Demo</title>
    <link rel="stylesheet" href="../LC-showcase/game-style.css" />
        <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
  </head>
  <body>
    <div class="container">
      <div class="row">
        <!-- Game Screen Canvas-->
        <div class="column"> 
          <div id="container"></div>
          <button class="defaultButton" id="toggleMap">Show Map</button>
        </div>
        <!-- Gemini + Player Chat Functionality -->
        <div class="column"> 
          <div class="instructions">
            <div id="message_display"></div>
            <input
              type="text"
              id="user-input"
              size="60"
              rows="5"
              placeholder="Type your message to the Live Coach..."
            /><br>
            <button id="speechtotext" disabled>Hold SPACE BAR to Speak!</button>
            <br><input type="checkbox" id="speak-response" name="speak-response">
            <label for="speak-response">Speak response</label>
          </div>
        </div>
      </div>
    </div>
    <p hidden id="goal">Goal</p>
 
    <div class="whiteboard" id="whiteboard">
      <div id="whiteboard-map" style="height: 480px; width: 100%; display: none;"></div>
    </div>
    <div id="map" style="height: 500px; width: 100%; max-width: 1000px; background: #444;"></div>

    <a class="example" href="?Game=SuperMetroid" style="display: none;">Super Metroid</a>
    <div id="gameDisplay" style="display: none;">No game selected</div>
    
    <script type="module">
      // ---------- Imports ----------
      import { GoogleGenAI } from "https://esm.run/@google/genai";

      import { emulateSnesConsole } from "../SNES9x-framework/snes.mjs"; // Super Nintendo emulator import
      import { marked } from "https://esm.run/marked";
      // Map information and tools Import
      import all_rooms from "../SNES9x-framework/all_rooms.json" with { type: "json" };
      import all_nodes from "../SNES9x-framework/all_nodes.json" with { type: "json" };
      import { abstractify_pos_global, calculate_samus_pos, get_samus_room, map_area_names, map_area_offsets, crateria2_offset, crateria2_rooms } from "../SNES9x-framework/map_tools.mjs";
      import {
        getApiKey,  // gemini
        displayMessage,  // gemini
        getGameFromSearchParams,  // webpage
        initEmulatorPage,  // webpage
        initPlayerState,  // player state
        item_flags,  // item flags
        downloadGameState
      } from "../LC-showcase/helper.js"; // helper file
      import functionDeclarations from "../LC-showcase/function-declarations.json" with { "type": "json" }
      
      /* -------------------- Gemini Code -------------------- */
      let ai;
      let chat;
      let messageHistory = [];
      let instructions = "when you perform a function call, make sure you write text while calling that function";      
      
      let itemsCollected;

      async function initGeminiChat() {
        const API_KEY = getApiKey();
        ai = new GoogleGenAI({ apiKey: API_KEY });
      
        try {
          chat = ai.chats.create({
            model: "gemini-2.5-flash",
            config: {
              systemInstruction: instructions,
              tools: [{
                functionDeclarations: functionDeclarations
              }],
            }
          });

        } catch (error) {
          console.warn(error);
        }
      }
      
      async function sendGeminiMessage(message) {
        if (message) {
          if(message.from == "Player" || message.from == "Coach") {
            displayMessage(message.from, message.text, document.getElementById("message_display"), messageHistory); // Displays Player response on screen
          }
            
          try {
            return; // holding off Gemini responses for now
            let response = await chat.sendMessage({
              message: `from=${message.from.toLowerCase()}\n` + message.text,
            });
            
            if (!response.functionCalls) {
              displayMessage("Coach", response.text, document.getElementById("message_display"), messageHistory);
            } else {
              while (response.functionCalls) {
                const functionResponseParts = [];
                for (let call of response.functionCalls) {
                  if (knownFunctions[call.name]) {
                    displayMessage("FunctionCall", call.name + " " + JSON.stringify(call.args), document.getElementById("message_display"), messageHistory);
                    let result = undefined;
                    try {
                      result = await knownFunctions[call.name](call.args);
                    } catch(error) {
                      console.warn("Error executing function:", call.name, error);
                      result = "Error: " + error.message; // Return error message if function fails
                    }
                     
                    displayMessage("FunctionResults", JSON.stringify(result), document.getElementById("message_display"), messageHistory);
                    functionResponseParts.push({
                      functionResponse: {
                        name: call.name,
                        response: {text: result},
                      },
                    });
                  }
                }

                if (functionResponseParts) {
                  response = await chat.sendMessage({
                    message: functionResponseParts,
                  });
                  displayMessage("Coach", response.text, document.getElementById("message_display"), messageHistory);
                  
                }
              }
            }
            
          } catch (error) {
            console.warn(error);
          }
        }
      }
      
      /* -------------------- Super Nintendo Emulator Code -------------------- */
      let dv;
      let knownFunctions;
      let isListening;
      let recognition;
      
      const gameSelected = getGameFromSearchParams();
      let currentPlayerState = {};

      // Player Object for Super Metroid Map
      let player = {
        x: 258, 
        y: 562, // coordinates
        marker: null, // pink circle indicator on map to show player
        range: null, // white circle indicator to show player range
        nodeList: [], // list of associated nodes within range
        closestNode: "Landing_Site_Ship" // closest node to player
      }; 

      // Loading Function for SNES ROMs
      async function loadBinary(url) {
        let response = await fetch(url);
        return new Uint8Array(await response.arrayBuffer());
      }
      
      // Initialize setup
      window.onload = async function () {
        // displays the current game title on screen
        const gameElement = document.getElementById("gameDisplay");
        if (gameSelected) {
          gameElement.innerHTML = `You are playing: <strong> ${gameSelected}</strong>`;
        } else {
          window.location.assign("?Game=SuperMetroid");
        }     
        
        // Retrieving general prompt + appropriate game prompt
        let generalPrompt = await fetch('../prompts/coach-prompt.md');
        instructions = instructions.concat(await generalPrompt.text());
        let gamePrompt = await fetch(`../prompts/${gameSelected}.md`);
        instructions = instructions.concat(await gamePrompt.text());
        
        // Loading in appropriate Game ROM and Save State (if available)
        let romBytes; // Loading in SNES Game ROM
        let stateBytes; // Loading in SNES Game Saved State
        const saveSlots = new Array(10);
        
        // Loading in Super Metroid ROM
        romBytes = await loadBinary(
          "../assets/Super Metroid.sfc"
        );
        // Loading in Super Metroid Save State created from exporting withing the webpage
        // Save state functionality for Coach
        stateBytes = await loadBinary(
          "../assets/sm_save_states/sm_ship.state"
        );
        saveSlots[4] = await loadBinary(
          "../assets/sm_save_states/nextdoor-saveroom.state"
        );
        saveSlots[5] = await loadBinary(
          "../assets/sm_save_states/pre-morphball.state"
        );
        saveSlots[6] = await loadBinary(
          "../assets/sm_save_states/beginning_ship.state"
        );
        saveSlots[7] = await loadBinary(
          "../assets/sm_save_states/morph_ball_achieved.state"
        );
        saveSlots[8] = await loadBinary(
          "../assets/sm_save_states/missiles_achieved.state"
        );
        saveSlots[9] = await loadBinary(
          "../assets/sm_save_states/enemy_encounter.state"
        );

        let emulator = window.emulator = emulateSnesConsole(
          romBytes,
          stateBytes,
          document.querySelector("#container")
        );
          
        let tempTrue = true;
        function afterRun() {
          dv = new DataView(
            // using this line of code made it so that it was undefined towards accessing that dv, making the room location state just NULL all the time
            // emulator.retro.get_memory_data(2).buffer
            // it was fixed by returning this back to how it was before, however i thought this was only the copy and not a direct influence??
            emulator.retro.get_memory_data(2).slice(0, 0x2000).buffer
          );

          let x = dv.getUint8(0x0b04);
          let y = dv.getUint8(0x0b06);
          var coords = abstractify_pos_global(dv, map_area_offsets);
          player.x = coords[0], player.y = coords[1];

          verifyPlayerState();
        }

        emulator.addEventListener("afterRun", afterRun);

        // initialize the emulator and chat functionality on player page as well as Gemini Chat
        initEmulatorPage(emulator);
        initChatPage();
        initGeminiChat();

        // Hide Leaflet map on load (wonky way). If I try to hide it beforehand, it breaks the display
        document.getElementById("map").style.display = "none";
      
        knownFunctions = {
          set_energy_level({level}) {
            dv.setUint8(0x09C2, level);
            return dv.getUint8(0x09C2);
          },
          get_player_state() {
            const state = getCurrentPlayerState(dv);
            return JSON.stringify(state);
          },
          save_to_slot({slot_index}) {
            saveSlots[slot_index] = emulator.retro.serialize().slice();
            return "Done.";
          },
          load_from_slot({slot_index}) {
            try {
              emulator.retro.unserialize(saveSlots[slot_index]);
              return "Done.";
            } catch (error) {
              return "Error: " + error;
            }
          },
          evaluate_js_with_confirmation({code}) {
            if (confirm("Allow running this code?\n\n"+code)) {
              return "Code execution result: "+ eval(code);
            } else {
              return "The user disallowed this code execution.";
            }
          },
          get_set_bits_from_packed_value({packed_value}) {
            // Function to get set bits from a packed value
            const bits = [];
            for (let i = 0; i < 16; i++) {
              if (packed_value & (1 << i)) {
                bits.push(i);
              }
            }
            return bits;
          },
          async get_next_step_on_plan_to_beat_game({nodeName, itemList}) {
            // return "Head to the right"; // placeholder value
            let response = await fetch("http://localhost:8008/next_node", {
              method: "POST",
              headers: {
              "Content-Type": "application/json"
              },
              body: JSON.stringify({ nodeName, itemList })
            });
            return await response.json();

          },
          async get_node_info({nodeName}) {
            // example: http://localhost:8008/node/Parlor_R1
            let response = await fetch("http://localhost:8008/node/" + nodeName);
            return await response.json();
          }
          ,
          set_whiteboard_content({msg}) {
            try {
              setWhiteboardContent(msg);
              return "Done.";
            } catch (e) {
              return "Error: " + (e && e.message ? e.message : e);
            }
          }
        };
        
        /* ----- Function for passing in current player state ----- */
        // Player State function (ONLY WORKS FOR SUPER METROID)
        function getCurrentPlayerState(dv) {
          return {
            energy: dv.getUint8(0x09C2),
            missiles: dv.getUint8(0x09C6),
            inventory: knownFunctions.get_set_bits_from_packed_value({packed_value: dv.getUint16(0x09A4, true)}),
            closestNode: player.closestNode
          }
        }

        // Function to check the player's past state compared to any new upcoming changes, if so update the state and pass the passive info to the coach
        function verifyPlayerState() {
          let newPlayerState = getCurrentPlayerState(dv);
          if (JSON.stringify(newPlayerState) !== JSON.stringify(currentPlayerState)) {
            currentPlayerState = newPlayerState;
            console.log(currentPlayerState);
            sendGeminiMessage({ to: "Coach", from: "Game", text: JSON.stringify(currentPlayerState) });
          }
        }
      };
      
      window.send_message = function(text) {
        sendGeminiMessage({ to: "Coach", from: "Player", text: ""+text });
      }
      window.download_game_state = function() {
        downloadGameState(emulator);
      }

      window.createMap = function() {
        const wb = document.getElementById('whiteboard');
        const mapDiv = document.getElementById('whiteboard-map');
        wb.innerHTML = '';
        mapDiv.style.display = 'block';
        wb.appendChild(mapDiv);
        generateMap('whiteboard-map', true);
      }

      window.download_chat_transcript = function() {
        const filename = "transcript.json";
        const transcriptContent = JSON.stringify(messageHistory);
        let element = document.createElement("a");
        element.setAttribute(
          "href",
          "data:text/plain;charset=utf-8," +
            encodeURIComponent(transcriptContent)
        );
        element.setAttribute("download", filename);
        element.style.display = "none";
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
      }
      
      window.load_state = function(slot_index) {
        knownFunctions.load_from_slot({slot_index});
      }

      /* --------------- Map Functionality --------------- */
      // Creates the leaflet map
      const base = {
        width: 18432, // pixels
        height: 16896, // pixels
        pixelsPerDegree: 128,
        offsetY: -14336,
        offsetX: -1280,
      };

      // Convert from pixel xy coords to the map coords
      // which expects y,x degrees
      function pxy_to_loc(pxy) {
        return [
          (base.offsetY + base.height - pxy[1]) / base.pixelsPerDegree,
          (base.offsetX + pxy[0]) / base.pixelsPerDegree,
        ];
      }
      const bounds = [
        [
          base.offsetY / base.pixelsPerDegree,
          base.offsetX / base.pixelsPerDegree,
        ],
        [
          (base.offsetY + base.height) / base.pixelsPerDegree,
          (base.offsetX + base.width) / base.pixelsPerDegree,
        ],
      ];
      const padding = Math.min(base.width, base.height) / 2;
      const maxBounds = [
        [
          (base.offsetY - padding) / base.pixelsPerDegree,
          (base.offsetX - padding) / base.pixelsPerDegree,
        ],
        [
          (base.offsetY + base.height + padding) / base.pixelsPerDegree,
          (base.offsetX + base.width + padding) / base.pixelsPerDegree,
        ],
      ];

      // ============ MAP GENERATION FUNCTION ============
      function generateMap(mapElementId, includePlayerTracking = false) {
        // Clean up existing map if it exists already
        const existingMap = window[mapElementId + '_leafletMap'];
        if (existingMap) {
          try { existingMap.remove(); } catch (e) { }
        }

        const mapInstance = L.map(mapElementId, {
          maxBounds: maxBounds,
          crs: L.CRS.Simple,
        }).fitBounds(bounds);

        // Create a custom pane for the player range circle, behind markers
        mapInstance.createPane('playerRangePane');
        mapInstance.getPane('playerRangePane').style.zIndex = 299;
        mapInstance.getPane('playerRangePane').style.pointerEvents = 'none';

        L.tileLayer(
          "https://bin0al.github.io/Super_Metroid_World_Map/Mapfiles/{z}/{x}/{y}.png",
          {
            minZoom: 3,
            maxZoom: 8,
            attribution:
              '<a href="https://www.snesmaps.com/">Base Map from snesmaps.com</a>',
            detectRetina: true,
          }
        ).addTo(mapInstance);

        // Add room rectangles
        function addRoomRectangle(room_name) {
          const pixels_per_maptile = 256;
          const room_info = all_rooms[room_name];
          const r = room_info["Region"];

          let rect_start_mt = room_info["Map_Pos"];
          rect_start_mt = [
            rect_start_mt[0] + map_area_offsets[r][0],
            rect_start_mt[1] + map_area_offsets[r][1],
          ];
          if (crateria2_rooms.includes(room_name)) {
            rect_start_mt[0] += crateria2_offset[0];
            rect_start_mt[1] += crateria2_offset[1];
          }

          const start_pxy = [
            rect_start_mt[0] * pixels_per_maptile,
            rect_start_mt[1] * pixels_per_maptile,
          ];

          const end_pxy = [
            start_pxy[0] + room_info["Extent"][0] * pixels_per_maptile,
            start_pxy[1] + room_info["Extent"][1] * pixels_per_maptile,
          ];

          const rect = L.rectangle([pxy_to_loc(start_pxy), pxy_to_loc(end_pxy)], {
            color: `hsl(${(360 * r) / 5}, 50%, 50%, 35%)`,
          }).addTo(mapInstance);

          rect.bindTooltip(
            `${room_name.replaceAll("_", " ")}, ${map_area_names[r]}`
          );
        }

        Object.keys(all_rooms).forEach(addRoomRectangle);

        // Add node circles
        function addNodeCircle(node_name, isMainMap = false) {
          const pos = all_nodes[node_name];
          const loc = pos_to_loc(pos)
          const circ = L.circle(loc, {
             radius: 0.2}).addTo(mapInstance);
          
          // Only track nodes for main map
          if (isMainMap) {
            player.nodeList.push({ circ, loc, name: node_name });
            circ.on('click', (event) => {
               fetch(node_name); // Will Fail!
               document.getElementById("goal").innerHTML = node_name;
            });
          }
          
          circ.bindTooltip(
           `${node_name.replaceAll("_", " ")}`
          );
        }

        Object.keys(all_nodes).forEach(name => addNodeCircle(name, includePlayerTracking));

        // Add player tracking elements if requested
        if (includePlayerTracking) {
          const start_loc = pos_to_loc([player.x, player.y]);
          const playerMarker = L.circle(start_loc, {
            radius: 0.2, color: `hsl(322, 50%, 50%)`,
          }).addTo(mapInstance);
        
          const playerRange = L.circle(start_loc, {
            radius: 0.5, color: `hsl(50, 10%, 70%)`,
            pane: 'playerRangePane'
          }).addTo(mapInstance);

          // Store references for main map updates
          mapInstance.playerMarker = playerMarker;
          mapInstance.playerRange = playerRange;
        }

        // Store map reference for later access
        window[mapElementId + '_leafletMap'] = mapInstance;
        return mapInstance;
      }

      const map = generateMap('map', true);

      function pos_to_loc(pos) {
        return pxy_to_loc([pos[0] * 16, pos[1] * 16])
      }

      // green marker: hsl(100, 100%, 50%)

      function update_pos() {
        const loc = pos_to_loc([player.x, player.y]);
        map.playerMarker.setLatLng(loc);
        map.playerRange.setLatLng(loc);
      }
      update_pos();

      // Function to calculate distance between two [lat, lng] points (Euclidean for small distances)
      function latLngDistance(a, b) {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];
        return Math.sqrt(dx * dx + dy * dy);
      }

      function pos_list_to_loc(pos_list) {
        return pos_list.map(pos_to_loc)
      }

      setInterval(update_pos, 100);

      // --- Adjacent node detection and closest node highlighting ---
      function adjacentNodeDetection() {
        const playerLoc = pos_to_loc([player.x, player.y]);
        const radius = map.playerRange.getRadius();
        // Find all adjacent nodes within radius
        const adjacent = player.nodeList.filter(obj => latLngDistance(obj.loc, playerLoc) <= radius);
        // console.log("Adjacent nodes:", adjacent.map(obj => obj.name));
        const adjacentNames = adjacent.map(obj => obj.name);
        // Find the closest node among all nodes (not just adjacent)
        let closest = null;
        let minDist = Infinity;
        for (const obj of adjacent) {
          const dist = latLngDistance(obj.loc, playerLoc);
          if (dist < minDist) {
            minDist = dist;
            closest = obj;
          }
        }
        // Color code: green for closest node, blue for others
        if(closest != null) {
          player.nodeList.forEach(obj => {
            if (obj === closest) {
              obj.circ.setStyle({ color: 'hsl(100, 100%, 50%)' }); // green
              player.closestNode = obj.name;
            } else {
              obj.circ.setStyle({ color: '#3388ff' }); // blue
            }
          });
        }
      }
      setInterval(adjacentNodeDetection, 1000);

      /* --------------- Chat Functionality --------------- */
      function initChatPage() {
        // Send message through pressing enter
        document.getElementById("user-input").addEventListener("keypress", (e) => {
          let textFieldValue = document.getElementById("user-input").value;
          if (e.key === "Enter" && textFieldValue.trim().length > 0) {
            sendGeminiMessage({ to: "Coach", from: "Player", text: textFieldValue });
            document.getElementById("user-input").value = ""; // Clears text box for new text
          }
        });
              
        emulator.canvas.addEventListener('keydown', (e) => {
          if(e.code === "Space" && !isListening) {
            try {
              recognition.start();
              isListening = true;
              console.log("Started listening...");
              document.getElementById("speechtotext").textContent = "!! Speaking !!";
            } catch (e) {
              console.warn("Recognition already started or error:", e);
            }
          }
        });

        // shortcut to enable Speech-to-Text
        emulator.canvas.addEventListener('keyup', (e) => {
          if(e.code === "Space" && isListening) {
            recognition.stop();
            isListening = false;
            console.log("Ending recognition...");
          }
        });

      }
            
      // Speech to Text Feature, ONLY WORKS IN CHROME
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        alert("Your browser does not support the Web Speech API.");
      } else {
        recognition = new SpeechRecognition();
        recognition.lang = 'en-US';

        recognition.onresult = function(event) {
          const transcript = event.results[0][0].transcript;
          document.getElementById("user-input").value = transcript;
          console.log("TRANSCRIPT: " + transcript);
        };

        recognition.onerror = function(event) {
          console.error("Speech recognition error:", event.error);
        };

        recognition.onend = function() {
          isListening = false;
          console.log("Stopped listening");
          document.getElementById("speechtotext").textContent = "Hold SPACE BAR to Speak!";
          if(document.getElementById("user-input").value.trim() != "") {
           sendGeminiMessage({ to: "Coach", from: "Player", text: document.getElementById("user-input").value });
            document.getElementById("user-input").value = "";
          }
        };
      }

      /* --------------- Whiteboard Functionality --------------- */
      let whiteboardUpdateInterval = null;

      function updateWhiteboardMap() {
        const wbMap = window['whiteboard-map_leafletMap'];
        if (!wbMap) return;

        // Update player marker position
        try {
          const loc = pos_to_loc([player.x, player.y]);
          if (wbMap.playerMarker) {
            wbMap.playerMarker.setLatLng(loc);
          }
          if (wbMap.playerRange) {
            wbMap.playerRange.setLatLng(loc);
          }
        } catch (e) {
          console.warn('Could not update player position on whiteboard map', e);
        }
      }

      function setWhiteboardContent(msg) {
        const wb = document.getElementById('whiteboard');
        if (!wb) {
          return;
        }

        // Clear any existing update interval
        if (whiteboardUpdateInterval) {
          clearInterval(whiteboardUpdateInterval);
          whiteboardUpdateInterval = null;
        }

        const text = (msg === undefined || msg === null) ? '' : String(msg).trim();
        if (!text) {
          wb.innerHTML = '<div style="opacity:0.6">Empty content</div>';
          return;
        }

        const lower = text.toLowerCase();

        // If the user asked for a map, create a Leaflet map inside the whiteboard
        if (lower === 'map' || lower.startsWith('map') || lower.includes('show map')) {
          wb.innerHTML = '';
          const mapDiv = document.createElement('div');
          mapDiv.id = 'whiteboard-map';
          mapDiv.style.width = '100%';
          mapDiv.style.height = '480px';
          wb.appendChild(mapDiv);

          // Generate map using the reusable function (with player tracking)
          generateMap('whiteboard-map', true);

          // Start continuously updating the player position on the whiteboard
          whiteboardUpdateInterval = setInterval(updateWhiteboardMap, 100);
          return;
        }

        // If it's an image URL, embed the image
        if (/^https?:\/\/.+\.(png|jpg|jpeg|gif|svg)(\?.*)?$/i.test(text)) {
          wb.innerHTML = '';
          const img = document.createElement('img');
          img.src = text;
          img.style.maxWidth = '100%';
          img.style.height = 'auto';
          wb.appendChild(img);
          return;
        }

        // Otherwise, render as Markdown/HTML (marked is already imported)
        wb.innerHTML = '';
        try {
          wb.innerHTML = marked(text);
        } catch (e) {
          // Fallback to plain text
          wb.textContent = text;
        }
      }

    </script>
  </body>
</html>
